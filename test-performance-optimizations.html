<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Optimizations Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #1a1a1a;
            color: #fff;
        }
        .test-section {
            background: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border: 1px solid #444;
        }
        .test-result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
        }
        .success {
            background: #1a4a1a;
            border: 1px solid #4a8a4a;
        }
        .error {
            background: #4a1a1a;
            border: 1px solid #8a4a4a;
        }
        .info {
            background: #1a1a4a;
            border: 1px solid #4a4a8a;
        }
        button {
            background: #4a4a8a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #5a5a9a;
        }
        .performance-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .metric {
            background: #333;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
        }
        .metric-value {
            font-size: 24px;
            font-weight: bold;
            color: #4a8a4a;
        }
    </style>
</head>
<body>
    <h1>Performance Optimizations Test</h1>
    
    <div class="test-section">
        <h2>1. DOM Caching Test</h2>
        <p>Testing DOM element caching functionality...</p>
        <div id="dom-test-results"></div>
        <button onclick="testDOMCaching()">Run DOM Caching Test</button>
    </div>

    <div class="test-section">
        <h2>2. Parameter Handler Unification Test</h2>
        <p>Testing unified parameter handler functionality...</p>
        <div id="parameter-test-results"></div>
        <button onclick="testParameterHandler()">Run Parameter Handler Test</button>
    </div>

    <div class="test-section">
        <h2>3. Memory Management Test</h2>
        <p>Testing memory cleanup and abort controllers...</p>
        <div id="memory-test-results"></div>
        <button onclick="testMemoryManagement()">Run Memory Management Test</button>
    </div>

    <div class="test-section">
        <h2>4. Performance Metrics</h2>
        <div class="performance-metrics">
            <div class="metric">
                <div class="metric-value" id="dom-query-count">0</div>
                <div>DOM Queries</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="parameter-updates">0</div>
                <div>Parameter Updates</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="memory-usage">0</div>
                <div>Memory Usage (MB)</div>
            </div>
            <div class="metric">
                <div class="metric-value" id="execution-time">0</div>
                <div>Execution Time (ms)</div>
            </div>
        </div>
        <button onclick="runPerformanceBenchmark()">Run Performance Benchmark</button>
    </div>

    <div class="test-section">
        <h2>5. Integration Test</h2>
        <p>Testing all optimizations together...</p>
        <div id="integration-test-results"></div>
        <button onclick="runIntegrationTest()">Run Integration Test</button>
    </div>

    <script type="module">
        // Import the App class to test the optimizations
        import { App } from './src/core/App.js';

        let app;
        let testResults = {
            domCaching: false,
            parameterHandler: false,
            memoryManagement: false,
            performance: false
        };

        // Mock DOM elements for testing
        const mockElements = {
            'midi-connect': document.createElement('button'),
            'midi-disconnect': document.createElement('button'),
            'midi-refresh': document.createElement('button'),
            'midi-preset-select': document.createElement('select'),
            'scene-preset-select': document.createElement('select'),
            'preset-file-input': document.createElement('input'),
            'add-cc-control': document.createElement('button'),
            'add-note-control': document.createElement('button'),
            'add-audio-mapping-control': document.createElement('button'),
            'mapping-test': document.createElement('button'),
            'mapping-save': document.createElement('button'),
            'mapping-load': document.createElement('button'),
            'save-scene-button': document.createElement('button'),
            'load-scene-button': document.createElement('button'),
            'interpolation-duration': document.createElement('input'),
            'interpolation-duration-value': document.createElement('span'),
            'interpolation-easing': document.createElement('select'),
            'debug-interpolation': document.createElement('button')
        };

        // Add mock elements to DOM
        Object.entries(mockElements).forEach(([id, element]) => {
            element.id = id;
            document.body.appendChild(element);
        });

        // Mock fetch for testing
        const originalFetch = window.fetch;
        window.fetch = async (url, options = {}) => {
            if (url.includes('/presets/')) {
                return {
                    ok: true,
                    text: () => Promise.resolve('<a href="test-preset.json">test-preset.json</a>'),
                    json: () => Promise.resolve({ controls: [] })
                };
            }
            return originalFetch(url, options);
        };

        // Test DOM Caching
        window.testDOMCaching = async () => {
            const resultsDiv = document.getElementById('dom-test-results');
            resultsDiv.innerHTML = '';

            try {
                // Initialize app
                app = new App();
                
                // Test DOM cache initialization
                app.initializeDOMCache();
                
                // Test cached element retrieval
                const cachedElement = app.getCachedElement('midi-connect');
                const directElement = document.getElementById('midi-connect');
                
                if (cachedElement === directElement) {
                    addResult(resultsDiv, 'success', '‚úÖ DOM caching working correctly');
                    testResults.domCaching = true;
                } else {
                    addResult(resultsDiv, 'error', '‚ùå DOM caching failed');
                }

                // Test performance improvement
                const startTime = performance.now();
                for (let i = 0; i < 1000; i++) {
                    app.getCachedElement('midi-connect');
                }
                const cachedTime = performance.now() - startTime;

                const startTime2 = performance.now();
                for (let i = 0; i < 1000; i++) {
                    document.getElementById('midi-connect');
                }
                const directTime = performance.now() - startTime2;

                addResult(resultsDiv, 'info', `üìä Cached queries: ${cachedTime.toFixed(2)}ms, Direct queries: ${directTime.toFixed(2)}ms`);
                
                if (cachedTime < directTime) {
                    addResult(resultsDiv, 'success', `‚úÖ Performance improvement: ${((directTime - cachedTime) / directTime * 100).toFixed(1)}% faster`);
                }

            } catch (error) {
                addResult(resultsDiv, 'error', `‚ùå DOM caching test failed: ${error.message}`);
            }
        };

        // Test Parameter Handler
        window.testParameterHandler = async () => {
            const resultsDiv = document.getElementById('parameter-test-results');
            resultsDiv.innerHTML = '';

            try {
                // Initialize app
                app = new App();
                await app.init();

                // Test parameter handler configuration
                if (App.PARAMETER_HANDLERS && App.PARAMETER_HANDLERS.size > 0) {
                    addResult(resultsDiv, 'success', `‚úÖ Parameter handler configured with ${App.PARAMETER_HANDLERS.size} parameters`);
                } else {
                    addResult(resultsDiv, 'error', '‚ùå Parameter handler not configured');
                    return;
                }

                // Test parameter updates
                const testParameters = [
                    'movementAmplitude',
                    'rotationAmplitude',
                    'scaleAmplitude',
                    'gridWidth',
                    'bloomStrength'
                ];

                let successCount = 0;
                for (const param of testParameters) {
                    try {
                        const originalValue = app.state.get(param);
                        app.handleParameterUpdate(param, 0.5);
                        const newValue = app.state.get(param);
                        
                        if (newValue !== originalValue) {
                            successCount++;
                        }
                    } catch (error) {
                        addResult(resultsDiv, 'error', `‚ùå Parameter update failed for ${param}: ${error.message}`);
                    }
                }

                if (successCount === testParameters.length) {
                    addResult(resultsDiv, 'success', `‚úÖ All parameter updates working correctly (${successCount}/${testParameters.length})`);
                    testResults.parameterHandler = true;
                } else {
                    addResult(resultsDiv, 'error', `‚ùå Some parameter updates failed (${successCount}/${testParameters.length})`);
                }

                // Test performance
                const startTime = performance.now();
                for (let i = 0; i < 1000; i++) {
                    app.handleParameterUpdate('movementAmplitude', Math.random());
                }
                const updateTime = performance.now() - startTime;
                
                addResult(resultsDiv, 'info', `üìä 1000 parameter updates completed in ${updateTime.toFixed(2)}ms`);

            } catch (error) {
                addResult(resultsDiv, 'error', `‚ùå Parameter handler test failed: ${error.message}`);
            }
        };

        // Test Memory Management
        window.testMemoryManagement = async () => {
            const resultsDiv = document.getElementById('memory-test-results');
            resultsDiv.innerHTML = '';

            try {
                // Initialize app
                app = new App();
                await app.init();

                // Test abort controllers
                if (app.abortControllers && app.abortControllers instanceof Map) {
                    addResult(resultsDiv, 'success', '‚úÖ Abort controllers initialized');
                } else {
                    addResult(resultsDiv, 'error', '‚ùå Abort controllers not initialized');
                    return;
                }

                // Test event listener tracking
                if (app.eventListeners && Array.isArray(app.eventListeners)) {
                    addResult(resultsDiv, 'success', '‚úÖ Event listener tracking initialized');
                } else {
                    addResult(resultsDiv, 'error', '‚ùå Event listener tracking not initialized');
                    return;
                }

                // Test cleanup
                const initialEventListeners = app.eventListeners.length;
                app.addTrackedEventListener(document.createElement('button'), 'click', () => {});
                
                if (app.eventListeners.length > initialEventListeners) {
                    addResult(resultsDiv, 'success', '‚úÖ Event listener tracking working');
                } else {
                    addResult(resultsDiv, 'error', '‚ùå Event listener tracking failed');
                    return;
                }

                // Test cleanup
                app.removeAllEventListeners();
                if (app.eventListeners.length === 0) {
                    addResult(resultsDiv, 'success', '‚úÖ Event listener cleanup working');
                    testResults.memoryManagement = true;
                } else {
                    addResult(resultsDiv, 'error', '‚ùå Event listener cleanup failed');
                }

                // Test abort controller cleanup
                app.abortControllers.set('test', new AbortController());
                app.cleanup();
                
                if (app.abortControllers.size === 0) {
                    addResult(resultsDiv, 'success', '‚úÖ Abort controller cleanup working');
                } else {
                    addResult(resultsDiv, 'error', '‚ùå Abort controller cleanup failed');
                }

            } catch (error) {
                addResult(resultsDiv, 'error', `‚ùå Memory management test failed: ${error.message}`);
            }
        };

        // Performance Benchmark
        window.runPerformanceBenchmark = async () => {
            const resultsDiv = document.getElementById('integration-test-results');
            resultsDiv.innerHTML = '';

            try {
                // Initialize app
                app = new App();
                await app.init();

                const metrics = {
                    domQueries: 0,
                    parameterUpdates: 0,
                    memoryUsage: 0,
                    executionTime: 0
                };

                // Benchmark DOM queries
                const domStart = performance.now();
                for (let i = 0; i < 1000; i++) {
                    app.getCachedElement('midi-connect');
                    metrics.domQueries++;
                }
                const domTime = performance.now() - domStart;

                // Benchmark parameter updates
                const paramStart = performance.now();
                for (let i = 0; i < 1000; i++) {
                    app.handleParameterUpdate('movementAmplitude', Math.random());
                    metrics.parameterUpdates++;
                }
                const paramTime = performance.now() - paramStart;

                // Calculate memory usage (approximate)
                if (performance.memory) {
                    metrics.memoryUsage = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                }

                metrics.executionTime = domTime + paramTime;

                // Update metrics display
                document.getElementById('dom-query-count').textContent = metrics.domQueries;
                document.getElementById('parameter-updates').textContent = metrics.parameterUpdates;
                document.getElementById('memory-usage').textContent = metrics.memoryUsage;
                document.getElementById('execution-time').textContent = metrics.executionTime.toFixed(2);

                addResult(resultsDiv, 'success', `üìä Performance benchmark completed:`);
                addResult(resultsDiv, 'info', `   ‚Ä¢ DOM queries: ${metrics.domQueries} in ${domTime.toFixed(2)}ms`);
                addResult(resultsDiv, 'info', `   ‚Ä¢ Parameter updates: ${metrics.parameterUpdates} in ${paramTime.toFixed(2)}ms`);
                addResult(resultsDiv, 'info', `   ‚Ä¢ Memory usage: ${metrics.memoryUsage}MB`);
                addResult(resultsDiv, 'info', `   ‚Ä¢ Total execution time: ${metrics.executionTime.toFixed(2)}ms`);

                testResults.performance = true;

            } catch (error) {
                addResult(resultsDiv, 'error', `‚ùå Performance benchmark failed: ${error.message}`);
            }
        };

        // Integration Test
        window.runIntegrationTest = async () => {
            const resultsDiv = document.getElementById('integration-test-results');
            resultsDiv.innerHTML = '';

            try {
                // Run all tests
                await testDOMCaching();
                await testParameterHandler();
                await testMemoryManagement();
                await runPerformanceBenchmark();

                // Summary
                const passedTests = Object.values(testResults).filter(Boolean).length;
                const totalTests = Object.keys(testResults).length;

                addResult(resultsDiv, 'success', `üéâ Integration test completed: ${passedTests}/${totalTests} tests passed`);

                if (passedTests === totalTests) {
                    addResult(resultsDiv, 'success', '‚úÖ All performance optimizations working correctly!');
                } else {
                    addResult(resultsDiv, 'error', '‚ùå Some optimizations need attention');
                }

            } catch (error) {
                addResult(resultsDiv, 'error', `‚ùå Integration test failed: ${error.message}`);
            }
        };

        // Helper function to add test results
        function addResult(container, type, message) {
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.textContent = message;
            container.appendChild(div);
        }

        // Auto-run basic tests on page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                runIntegrationTest();
            }, 1000);
        });
    </script>
</body>
</html> 